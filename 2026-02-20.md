# 2026-02-20
- "The more easy something looks the harder it is to program"
- "Thank other people & recognize them" TAP - Thank a Peer

Disabling buttons is bad, screen readers can't tab to them

Attributes aren't verified in Angular <button tacos="delicious"></button>  but can't do anything with them
<button [attr.aria-disabled]="form().invalid() || form().submitting()"></button>
zod doesn't have a way to say soemthing is required (To get around it, you have to say it has a min length, or say it's optional)

Usually put the providers in the routes, when you put it on a componenets provider, only available inside of this component or any of the children. When you move off of it and come back it reloads the data

# APIs
zod gen is like getting that from the api
Mapping to a late bound call, there's no guarantee it's gonna map
Anytime you remove a thing, change the meaning of a thing, or add a new thing, and it is required
    - You are possibly breaking clients.... once an api is deployed, it gonna be difficult to change because so many apps depend on it
    - You can add new stuff to the API tho
        - That is the secret message of the string calculator, just write enough for the requirements RIGHT NOW... premature additions are very difficult to change

TS only works at compile time, it will compile if q.content, it's living in a fantasy
- If you don't trsut apis, or failure is an option, make sure to validate the data!

Compile errors but not runtime errors in TS

Going outside process space, use async and await

# Containers
- Windows containers are abominations, they are NOT good
- Production .NET code is in Linux, developing on windows but deploys on linux
- You define a container image which is the layers that make up a container
- We need a way in our pipeline to compile the applciation in a "release mode"
    - Get it ready for the container but put it in a container that doesn't have a compiler
- The less things in a container the better

- csproj file has the nuget packages
- There is a windows kernel that Microsoft maintains that has linux
- There is this thing called OCI (Open Container Initiative) - can have a contianer runtime that isn't docker
    - Made it so there are standards
    -   -d is detached mode, run it in background
- It is easy and quick to publish code, deliver a container.....easy!!! All you need is a container runtime!!
    - Anyone is able to run his code, docker good
- You deploy to:
    - Servers. Terraform, whatever
    - "cloud" - Azure Container Services, Amazon Container Services
    - docker compose
    - Old days: docker swarm - spread across multiple machines
- Postgres: 5432
- SQL: 1433


- **Kubernetes**: Big ? gorilla of all the things you can deploy to (GOOGLE)
    - MADE IT OPEN SOURCE !!!!
        - Which kind of gave birth to the "Cloud Native" thing
    - Idea of Kubernetes, you can go to GitHub, download it, and you can run it

# Openshift
- Wont be running Postgres in a container... so 
- Open Shift - "Distribution" of Kubernetes from Red Hat
    - Paying for this instead of getting for free (Red Hat giving nice dashboard, nice tools, extra stuff)
- With Kubernetes, you have clusters 
    - A whole cluster exists 
    - Cluster made up of nodes
        - Nodes run *"pods"* which are one or more related containers (A deployment is what creates a pod)
- In your pipeliens in openshift you'll see like 3 files
    - "deployment"
    - "service"
    - "path" or "ingress"
- Every cluster have a minimum of 3 servers, which are the *control plane*, in charage of hundreds or dozens of other servers in the cluster
    - Post something to control plane it goes to a db called SCD
        - scheduler - trying to find your application a good home
        - api
        -eted?
    - "Promise Theory" "Desired State Configuration"
    - Tell the control plane, make your dreams come true! Tell it what you want and it does it
        -  It keeps it that way, keeps desired state. Whatever you say in config files. If server goes down, the control plane recognizes it and puts everything up in different server  (*containers.excalidraw file*)
- The cluster can auto scale up or scale down 
    - Scale horizontally instead
- Cant get more threads than processes available... so keep calling in more threads, hell no

*What does all of this have to do with async and await?*
-  If ur calling another API or db, need async or await
- Too many threads and not enough processes, use threads resonably, use async and await
- If your doing .NET 

- Can run kubernetes on old machine, own regular machine, can run it on digitalocean

DevOps  === kubernetes and OpenShift
    - It's pretty damn cool

