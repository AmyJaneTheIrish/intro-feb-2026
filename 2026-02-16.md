# 2026-02-16

# Topics for this week
- Real dev testing
    - System tests
    - Unit & integration tests
    - System integreation tests (punting)
- Intro to Angular
- Containers
    - Scaling / Threads / Memory (and Async/Await Details)
- Observability
    - Traces, Metrics, Logs
    - "Feedback loops" & DevOps
- More Pipeliens, Delivering Code
- Cloud, cloud Native, Kubernetes / OpenShift

# Our World Overview
- *"Functional"*: What the business actually needs
    - Business rules/requirements & implementing & enforcing them in code (translating)
- *Operational*
    - Our code running in production
    - Scaling, reliability, all that
    - "Runtime" vs "Development Time"
    - "Non-Functional"
- *"Development"*
    - Maintaining source control
    - Pipelines
    - Training
    - Documentation
- *Testing*
    - Old skool thinking aws devs cannot havea  local environemnt that replicates poduction so they can only write Unit Tests
    - Super low level, break encapsulation
- What if we took development stuff & married it to operational stuff, DevOps
- *"DevOps"*
    - Observability: observing that code running in production ("are people running those new features?")
    - Feature Toggles
    - Pipelines ("Living breathing thing that you should be tending to")
- *"Feedback Loops"*
    - Cybernetics: engingeering discipline, machine & human interaction stuff
    - Norbert Weiner
    - "Steering wheel on a ship"
        - Kubernetes
- *Inner Loop*
    - The things that happen on your machine before you push your code
- *Outer Loop*
    - After you push, so the pipeline - and ultimately, production


Account class which is a service, the other class is also a service
    - They are both in the same "assembly"
        - Pros: Can't ship code that doesn't compule. This is early bound
    - Go our separate ways, but in a "package", like a nuget package or NPM package or whatever
        - Still early bound 
        - The creator of the package can "get ahead of us"
    
    - Making it external - "late bound"
        - The scariest, flakies way possible. But we need to do it sometimes
        - Nexus: Scans all dependencies and makes sure there's no issues. Security

// I don't have any tests that fail if I comment out this line of code - good thing to live by

# Tests
- Unit Tests are tests a "unit" of code in isolation for other dependencies that change so frequently, they may "break" your test
- WE can't use the account's deposit method with the 'real' bonus calculotr ebcause it was changing & annoying the heck out of us because our tests would fail
- HARD LINE for something to be a unit test is:
    - It cannt touch the network, the file system, a db, a config file, or the clock
- *System Tests*: Proves business facing functionality. Isolated for backing services
- Dummies, Stubs, Mocks, Fakes - "real things, but not really real"
- *Unit Integration tests*: May touch file system, network, etc. but does not (yet) "prove" business facing functionality
- *System integration test*: Usually called something like "End to End Test"
- *Pipeline*: code like a workflow  

- *System Integration (End to End) tests TEND to be "black box tests"*
    - use other testing tools/languages than the system they are testing
    - Playwright - browser automation testing tool - Use typesrcipt (can use C#)
- *Unit Tests & Integrations tests are "white box test"*
    - "clear box" - these tests are written in the same language as the system under test,
    they have a reference to the assembly, creates instances of classes, call methods
    - They know "how the bread is buttered", , they break encapsulation
- *DOTNET is almost unique in this. It has a thing between these. "Gray box testing"*
    - Systems Tests
        - Let's us peer under the rug when we have t make sure these other things (side-effects) are happening
    - Another thing he loves about .NET apis - you can host them in your tests

    Lauches our API first in Program.cs


